# -*- coding: utf-8 -*-

# profile 관리
# 사용시 필요한 필수 로딩 함수, 모듈 등을 정의
# run으로 실행 가능
run my_profile


# 단축키 정리
# F9: 실행(라인 혹은 드래그 영역)
# ctrl + 1 : 라인단위 주석 처리 / 해제
# ctrl + 4 : 드래그 영역 주석 처리
# ctrl + 5 : 드래그 영역 주석 해제
    


# 1. 변수 선언
#    숫자로 시작 X, 특수기호 지양(. 사용 불가 > 호출 기능), 예약어 금지,
#    한글자 변수 선언 지양
a1 = 1
a2 = 2

a1 + a2 

s1 = 'abcd'
s1.upper()    # method 함수와 다름(객체가 괄호 밖으로 나와서 호출하는 방식)



# 2. 문자열 전달 / 색인
sql1 = 'select * from emp'    # 단일 라인의 문자열 선연 가능
# 다중 라인 문자열 기본적으로 선언 불가
# (''' 혹은 """ 으로 묶어서 전달 필수)
sql1 = '''select *    
            from emp 
           where deptno = 10'''

# 문자열 색인 가능(substr 가능)
s1 = 'abcde'
s1[1:3]    # 마지막 숫자의 자리까지 포함하지 않은 범위(시작은 0부터)
s1[2:4]

# 문자열 결합
'abc' + 'de'

# 문자열 반복
'abc' * 3

# 특수문자 ☆
u1 = '\u2606'

# 특수문자 ★
u2 = '\u2605'



# 3. 모듈의 사용(module)
#   R의 패키지와 유사함(여러 함수의 묶음)
#   import 명령어로 패키지 호출 가능

a1 = 10
a1 / 3 
round(a1/3, 3)      # 기본함수
trunc(a1/3)         # 기본함수 아님 

# 1) 모듈명만 호출
import math         # 모듈 호출
math.trunc(a1/3)    # 모듈명.함수명 형태로 사용 가능


# 2) 모듈명을 별칭과 함께 호출
import math as ms
ms.trunc(a1/3)


#3) 특정 함수만 호출
#   from 모듈명 import 함수명 as 별칭

from math import trunc
trunc(1.33)         #함수명 단독 사용 가능


l1 = [1, 2, 3, NA]  #name 'NA' is not defined

import numpy as np
l1 = [1, 2, 3, np.nan]

from numpy import nan as NA
l1 = [1, 2, 3, NA]


# 특정 모듈 내 함수 목록
dir(math)




# =============================================================================
# print
# =============================================================================
# 기본적으로 문자열 혹은 변수 출력
# 포맷 변경 구문을 통해 문자열 입/출력 구분 가능

# 포맷 변경
# %d : 정수 표현
# %f : 실수
# %s : 문자열

# 포맷 % 원본데이터
'%.2f' % 10
'%02d' % 2

print('abcd')
print('abcd.... %d.... %d' % (1, 2))

print('a1을 3으로 나눈 몫: trunc(a1/3)')
print('a1을 3으로 나눈 몫: %d' % trunc(a1/3))



# [ 연습 문제 ]
# v1에 100, v2에 3을 전달하여 다음과 같은 출력 완성
v1 = 100
v2 = 3

# 1) 100을 3으로 나눈 몫 : 33
print('100을 3으로 나눈 몫 : %d' % trunc(v1/v2))

# 2) 100을 3으로 나눈 나머지 : 1
v3 = v1 - 3 * trunc(v1/v2)
print('100을 3으로 나눈 나머지 : %d' % v3)
print('100을 3으로 나눈 나머지 : %d' % math.fmod(v1, v2))




# =============================================================================
# 형 변환 함수
# =============================================================================
'%d' % 12          #항상 문자열 리턴
'%d' % '12'        #불가(문자를 숫자로 변경 불가)

int('1234')        #정수
float('1234')      #실수
str(1234)          #문자

# 참고) 날짜변환 기본함수 X     

# 데이터 타입 확인 함수    
type(a1)




# =============================================================================
# 산술연산자
# =============================================================================
10 // 3            #몫
10 % 3             #나머지
2**4               #거듭제곱
math.pow(2, 4)     #거듭제곱(함수)



# =============================================================================
# 파일 입출력: input
# =============================================================================
# 사용자로부터 값을 입력받을 때 사용

ans1 = input('값을 입력하세요 : ')

# 참고: input 사용 시 에러 발생
# cmd 창에서 아래 명령어 순서대로 입력(설치를 요구하는 경우 Y 입력)
conda create -n spyder-cf -c conda-forge spyder
conda activate spyder-cf



# =============================================================================
# 파이썬 자료 구조
# =============================================================================
# 1. 리스트
#    - 기본 제공
#    - 가장 기본 자료 구조(1차원)
#    - R의 벡터와 유사
#    - 서로 다른 데이터 타입 전달 가능 
#    - 중첩 구조 가능

# 2. 딕셔너리
#    - 기본 제공
#    - R의 리스트와 유사
#    - key-value 구조

# 3. 배열
#    - numpy 모듈 제공
#    - 다차원 가능
#    - 하나의 데이터 타입 허용

# 4. 시리즈
#    - pandas 모듈 제공
#    - 1차원
#    - 하나의 데이터 타입 허용 

# 5. 데이터프레임
#    - pandas 모듈 제공
#    - key-value 구조
#    - 2차원



# =============================================================================
# 리스트
# =============================================================================
# 여러 값을 묶어서 전달하기 위한 자료 구조 
# 서로 다른 데이터 타입 전달 가능
# 벡터 연산(원소별 반복) 불가

# 1. 생성
l1 = [1, 2, 3, 4]
l1
type(l1)
l1 + 1                # can only concatenate list (not "int") to list

l2 = [1, 2, 3, '4']
l2

l3 = [1, 2, 3, [4, 5]]
l3


# 2. 색인
l1[0]                 # positional indexing
l1[0:3]               # slice indexing
l1[[0, 2]]            # 여러 개 동시 색인 불가(list indexing 불가)
l1[-1]                # 거꾸로 색인
l3[3]                 # [4, 5]

l1[1]                 # scalar return(차원 축소 발생)
l1[1:2]               # list return(차원 축소 방지)


# 참고) series의 기능
from pandas import Series

l1 + 1                # 연산 불가
Series(l1) + 1        # 연산 가능

l1[[1, 2]]            # 색인 불가
Series(l1)[[0, 2]]    # 색인 가능


# 3. 연산
l1 + 1                # 산술연산 불가
l1 > 1                # 비교 불가
l1 == 3               # 원소별 비교 X

l2 = [10, 20, 30, 40]

l1 + l2               # 리스트 확장(결합)
l1 * 3                # 리스트 반복


# 4. 구조 변경
l1 = l1 + [5]         # 원소 추가
l1.append(6)          # 원소 추가(객체 직접 수정)
l1.extend([7])        # 원소 추가, 리스트 확장
                      # (반드시 리스트로 전달 필요, 객체 직접 수정)
                      
l1.insert(1, 10)      # 원소 추가(위치 지정 가능, 객체 직접 수정)
l1.remove(10)         # 값이 10인 원소 삭제(객체 직접 수정)
del(l1[1])            # 2번째 순서의 원소 삭제(위치 기반 수정)
del(l1)               # 객체 자체 삭제

l1 = [1, 2, 3, 4, 5]
l1.pop()              # 마지막 원소 추출 및 삭제(객체 직접 수정)
l1.pop(1)             # 지정 위치 원소 추출 및 삭제(객체 직접 수정)

l2 = [1, 3, 10, 2, 5]
l2.sort(); l2         # 정렬(객체 직접 수정)
l2.sort(reverse = True); l2

l2.count(5)           # 지정 원소 count


                      
                      
# [ 함수와 메서드 ]
# 1. 함수 : input value(자료구조)가 함수 안에 전달
# 2. 메서드 : input value(자료구조)가 먼저 호출 > 이어서 함수 출력

dir(module name)
import math
dir(math)             # 함수 목록

dir(variable name)
dir(l1)               # 메서드 목록
v1 = 'Hello World'
dir(v1)



# =============================================================================
# 문자열 메서드
# =============================================================================
# 1. 추출
a1 = 'abcde ab'
a1[1:3]
a1[:3]                # 처음부터 2자리
a1[1:]                # 끝까지
a1[:]                 # 전체 indexing


# 2. 대소치환
a1.upper()            # 대문자
a1.lower()            # 소문자
a1.title()            # 카멜 표기법


# 3. 시작 / 끝 여부
a1.startswith('a')    # 시작 여부
a1.endwith('a')       # 끝 여부

a1.startswith('b', 1) # 두번째 값 b 여부
a1[1].startswith('b') # 두번째 값 b 여부2


# 4. 공백 / 문자열 제거
a2 = 'abc '
a2.strip()            # 양쪽 공백 제거
a2.lstrip()           # 왼쪽 공백 제거
a2.rstrip()           # 오른쪽 공백 제거

a1.lstrip('a')        # 문자열 'a' 제거


# 5. 치환
a1.replace?           # a1.replace(old, new, count=-1, /)
a1.replace('a', 'A')  # 해당 문자열 치환
a1.replace('a', '')   # 해당 문자열 삭제


# 6. 분리
a3 = 'a#b#c#d'
a3.split('#')         # 지정 문자열로 리스트 분리


# 7. 위치 확인 
a3.find('#')          # 처음 발견된 문자열 위치 리턴(n번째 발견된, etc. 불가)
a3.find('#', 2)       # 위치 확인 시작 위치 조정 가능




# [ 연습 문제 ]
# 1. 1~5 까지의 숫자 원소를 갖는 l1 생성
l1 = [1, 2, 3, 4, 5]
# 2. 10, 20, 30, 40, 50 숫자 원소를 갖는 l2 생성
l2 = [10, 20, 30, 40, 50]
# 3. l1에서 두번째 원소 삭제
del(l1[1]); l1
# 4. l2에서 40 원소 삭제
l2.remove(40)
# 5. l1의 세번째에 100 삽입
l1.insert(2, 100); l1
# 6. 두 원소를 하나의 리스트로 합쳐 출력
l1 + l2



# [ 연습 문제 ]
ename = 'smith'
tel = '02)333-4456'
jumin = '901111-1111111'
vid = 'abc1234!'

# 1) ename의 두번째 글자가 m으로 시작하는지 여부 확인
ename[1].startswith('m')

# 2) tel 국번(333) 추출
tel[tel.find(')') + 1:tel.find('-')]
(tel.split(')')[1]).split('-')[0]

# 3) 여자인지 여부 확인(True, False 확인)
jumin[7].startswith('2')
jumin[7] == '2'


