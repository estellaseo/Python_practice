# -*- coding: utf-8 -*-

# =============================================================================
# 논리연산자
# =============================================================================
v1= 10

(v1 >= 3) and (v1 < 15)
(v1 >= 3) & (v1 < 15)

(v1 <= 3) or (v1 > 15)
(v1 <= 3) | (v1 > 15)

# [ 참고 ] 벡터 논리 연산자 - 여러개의 논리값 처리
l1 = [1, 2, 5, 10, 12, 17]
l1 >= 3                                  # 비교연산자 사용 불가

from pandas import Series
Series(l1) >= 3                          # 각 원소별 비교 가능
(Series(l1) >= 3) and (Series(l1) < 15)  # 에러 발생(여러 값 수행 X)
(Series(l1) <= 3) or (Series(l1) > 15)

(Series(l1) >= 3) & (Series(l1) < 15)    # 사용 가능
(Series(l1) <= 3) | (Series(l1) > 15)




# =============================================================================
# 벡터 연산
# =============================================================================
l2 = ['acd', 'dfdf', 'dfdf']
l2.upper()                               # 리스트에 적용 불가
Series(l2).upper()                       # Series에 적용 불가
l2[0].upper()                            # 문자열 적용 가능




# =============================================================================
# 사용자 정의 함수
# =============================================================================
# 1) 축약형
#    간단한 함수 정의에 용이 > 단순 리턴의 경우
function_name = lambda input_value : return_value

# 예시 1) 숫자를 입력받아 10을 더한 값 리턴
f1 = lambda x : x + 10
f1(100)

# 예시 2) 문자열을 입력받아 대문자로 치환
f2 = lambda x : x.upper()
f2('abcd')

# 예시 3) 두 수를 입력받아 두 수의 합 리턴
f3 = lambda x, y : x + y
f3(3, 4)
f3??                                     # 코드 확인

# 예시 4) 두 수를 입력받아 두 수의 합 리턴(인수의 기본값 선언)
#         x가 기본값을 가질 경우 y도 반드시 기본값을 가져야 함
f4 = lambda x = 0, y : x + y             # y 디폴트 생략 불가
f4 = lambda x = 0, y = 0 : x + y         # 정상 작동


# 2) 기본형
def function_name(input_value) :
    body
    return return_value




# =============================================================================
# 적용 함수
# =============================================================================
# 1. 1차원 원소별 적용(in R : sapply, mapply)
#    - map 함수: 적용 객체 제한 X (리스트, 1차원 배열, 시리즈)
l1 = ['1,200', '1,300', '1,400']

f1 = lambda x : int(x.replace(',', ''))
list(map(f1, l1))                        # 결과 확인을 위한 list 선언



#    - map 메서드: 시리즈만 가능

# 2. 2차원 행별 / 열별 적용(in R : apply)
#    - apply 메서드: 데이터프레임만 가능
#    - axis로 방향 결정

# 3. 2차원 원소별 적용(in R : apply - margin : c(1,2))
#    - if statement, string methods > scalar에만 적용 가능한 경우
#    - applymap 메서드: 데이터프레임만 가능


# [ 연습 문제 ]
l1 = [1, 2, 3, 4, 5]
l2 = [10, 20, 30, 40, 50]
l3 = ['abc@gmail.com', 'a1234@daum.net']
l4 = ['Smith', 'Allen']
l5 = ['02)345-9984', '031)2245-5683']

# 1) l1에 모든 원소에 10을 더한 결과 리턴
f1 = lambda x : x + 10
list(map(f1, l1))

# 2) l1과 l2 각 원소의 합 리턴
f2 = lambda x, y : x + y
list(map(f2, l1, l2))

# 3) l3에서 각 원소의 이메일 아이디 리턴
f3 = lambda x : x.split('@')[0]
list(map(f3, l3))

# 4) l1**l2
f4 = lambda x, y : x ** y
list(map(f4, l1, l2))

# 5) l5 국번 추출
f5 = lambda x : x.split(')')[1].split('-')[0]
list(map(f5, l5))

# 6) l4와 l5를 이용하여 아래와 같은 형식 리턴
#    이름: Smith, 전화번호: 02)345-9984
f6 = lambda x, y : print('이름: %s, 전화번호: %s' % (x, y))
list(map(f6, l4, l5))




# =============================================================================
# 반복문
# =============================================================================
# 1. for문
for i in value :
    body
    
for i in range(1, 11) :
    print('%2d' % i)
    
    
# 예시 1) 아래 리스트에 대해 각 원소에 10 더한 결과 리턴
l1 = [1, 2, 3, 4, 5]

vresult = []
for i in l1 :
    vresult.append(i + 10)
vresult

# 예시 2) 1 ~ 100 총 합 리턴
vsum = 0
for i in range(1, 101):
    vsum = vsum + i
vsum


# 2. while문
# 예시 1)
i = 1
vsum = 0
while i <= 100 :
    vsum = vsum + i
    i = i + 1
vsum




# =============================================================================
# 중첩 for문
# =============================================================================
for i in range(1, 11) :
    for j in ['a', 'b', 'c'] :
        print('i : %s, j : %s' % (i, j))


# 예시) 아래의 형태로 출력
# 1 2 3
# 4 5 6
# 7 8 9

l1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for i in l1 :
    for j in i :
        print(j, end = ' ')
    print()
    


# [ 연습 문제 ]
# 아래 중첩 리스트에 대해 2차원 형태로 출력(위치 기반)
l2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] 

# 1.
for i in range(0, 4) :
    for j in range(0, 3) :
        print('%2d' % l2[i][j], end = ' ')
    print()
    
# 2.    
l3 = [[1, 2, 3], [4, 5, 6, 7], [8, 9], [10, 11, 12]] 
for i in range(0, len(l3)) :
    for j in range(0, len(l3[i])) :
        print('%2d' % l3[i][j], end = ' ')
    print()




# =============================================================================
# 조건문
# =============================================================================
if condition :
    True
else :
    False
    
# 예시) v1 값이 10보다 클 경우 5를 더하고, 10보다 작거나 같을 경우 20을 더하여 리턴
v1 = 10

if v1 > 10 :
    v2 = v1 + 5 
else :
    v2 = v1 + 20


# 예시) l1 각 원소가 10보다 클 경우 5를 더하고, 10보다 작거나 같을 경우 20을 더하여 리턴
l1 = [1, 11, 20, 5]

# - 리스트 조건 불가
if l1 > 10 :
    v2 = v1 + 5
else :
    v2 = v1 + 20
    

# - if문 여러 값 동시 전달 불가
from pandas import Series

if Series(l1) > 10 :
    v2 = v1 + 5
else :
    v2 = v1 + 20 
    
# for + if
vresult = []
for i in l1 :
    if i > 10 :
        vresult.append(i + 5)
    else :
        vresult.append(i + 20)
vresult  
        
        
        
#[ 연습 문제 ]
# 부서번호가 10번일 경우 10%, 20이면 11%, 30이면 12% 인상한 결과 리턴
vdeptno = [10, 10, 20, 30]
vsal = [800, 2000, 3000, 2500]

new_sal = []
for i in range(0, len(vsal)) :
    if vdeptno[i] == 10 :
        new_sal.append(round(vsal[i] * 1.1)),
    elif vdeptno[i] == 20 :
        new_sal.append(round(vsal[i] * 1.11)),
    elif vdeptno[i] ==  30 :
        new_sal.append(round(vsal[i] * 1.12))
        
        

