# -*- coding: utf-8 -*-

# profile 관리
# - 사용시 필요한 필수 로딩 함수, 모듈 정의
# - run으로 실행 가능
run my_profile                  # my_profile.py 파일이 존재해야 함(홈디렉토리에)

# 단축키 정리
# F9 : 실행(라인 혹은 드래그 영역)
# ctrl + 1 : 라인단위 주석 처리 / 해제
# ctrl + 4 : 구분라인 포함 주석 처리
# ctrl + 5 : 구분라인 포함 주석 해제

# 1. 변수 선언
# 숫자로 시작 X, 특수기호 자제(. 불가), 예약어 금지, 한글자 변수 선언 자제
a1 = 1
a2 = 2

a1 + a2

s1 = 'abcd'
s1.upper()    # 메서드(함수 비슷하지만 객체가 빠져서 호출하는 방식)

# 2. 문자열 전달 / 색인 / 결합
sql1 = 'select * from emp'       # 단일 라인의 문자열 선언 가능

# 다중 라인 문자열 기본적으로 선언 불가 (''' 혹은 """으로 묶어서 전달 필요)
sql2 = '''select *               
          from emp               
         where deptno = 10'''

# 문자열 색인 가능(문자열 추출(substr 기능))         
s1 = 'abcde'         
s1[1:3]         # 마지막 범위 포함하지 않고(그 이전까지) 추출(시작숫자:0)
s1[2:4]
         
# 문자열 결합
'abc' + 'de'   # 문자열 결합
'abc' * 3      # 문자열 반복

u1 = '\u2605'
u1 * 5

# 3. 모듈(module)
# - R의 패키지와 비슷(여러 함수의 묶음)
# - import로 호출 가능

a1 = 10
round(a1/3, 3)     # 기본함수
trunc(a1/3)        # 기본함수가 아님

# 1) 모듈명만 호출
import math        # 모듈 호출
math.trunc(a1/3)   # 모듈명.함수명 형태로 사용 가능

# 2) 모듈명을 별칭과 함께 호출
import math as ma
ma.trunc(a1/3)

# 3) 특정 함수만 호출
# from 모듈명 import 함수명 as 별칭

from math import trunc
trunc(1.33)              # 함수명 단독 사용 가능


l1 = [1,2,3,NA]          # NA 사용 불가

import numpy as np
l1 = [1,2,3,np.nan] 

from numpy import nan as NA
l1 = [1,2,3,NA] 

# 특정 모듈 내 함수 목록***
dir(math)

# =============================================================================
# print
# =============================================================================
# - 기본적으로 문자열 혹은 변수 출력
# - 포맷 변경 구문을 통해 문자열 출력과 입력 구분할 수 있음

# 포맷 변경
# %d : 정수
# %f : 실수
# %s : 문자열

# 포맷 % 원본데이터
'%.2f' % 10
'%02d' % 2

print('abcd')
print('abcd.... %d ... %d' % (1,2))

print('a1을 3으로 나눈 몫 : trunc(a1/3)')
print('a1을 3으로 나눈 몫 : %d' % trunc(a1/3))


# [ 연습 문제 ]
# v1에 100, v2에 3을 전달하여 다음과 같은 출력 완성
v1 = 100
v2  = 3

# 1) 100을 3으로 나눈 몫 : 33
print('100을 3으로 나눈 몫 : %d' % trunc(v1/v2))

# 2) 100을 3으로 나눈 나머지 : 1
v3 = v1 - (3*trunc(v1/v2))
print('100을 3으로 나눈 나머지 : %d' % v3)

s1 = '100을 3으로 나눈 나머지 : %d' % v3

# =============================================================================
# 형 변환 함수
# =============================================================================
'%d' % 12      # 항상 문자열 리턴
'%d' % '12'    # 불가(문자를 숫자로 변경 불가)

a1 = int('1234')
float('1234')
str(1234)

type(a1)      # 데이터 타입 확인


# =============================================================================
# 산술연산자
# =============================================================================
10 // 3        # 몫
10 % 3         # 나머지
2**4           # 거듭제곱
math.pow(2,4)  # 거듭제곱(함수)


# =============================================================================
# 파일 입출력 : input 
# =============================================================================
# - 사용자로부터 값을 입력받을 때 사용

# 참고 : input 사용 시 에러 발생
# cmd 창에 아래 명령어 순서대로 입력(설치를 요구하는 경우 Y 입력)
# spyder-cf 실행

conda create -n spyder-cf -c conda-forge spyder
conda activate spyder-cf

ans1 = input('값을 입력하세요 : ')
ans1


# =============================================================================
# 파이썬 자료 구조
# =============================================================================
# 1. 리스트
# - 기본 제공
# - 가장 기본 자료 구조(1차원)
# - R의 벡터와 유사
# - 서로 다른 데이터 타입 전달 가능
# - 중첩 구조 가능

# 2. 딕셔너리
# - 기본 제공
# - R의 리스트와 유사
# - key-value 구조

# 3. 배열 
# - numpy 모듈 제공
# - 다차원 가능
# - 하나의 데이터 타입 허용

# 4. 시리즈
# - pandas 모듈 제공
# - 1차원
# - 하나의 데이터 타입 허용

# 5. 데이터프레임
# - pandas 모듈 제공
# - key-value 구조
# - 2차원


# =============================================================================
# 리스트
# =============================================================================
# - 여러 값을 묶어서 전달하기 위한 자료 구조
# - 서로 다른 데이터타입 전달 가능
# - 벡터 연산(원소별 반복) 불가

# 1. 생성
l1 = [1,2,3,4]
l1
type(l1)

l2 = [1,2,3,'4']
l2

l3 = [1,2,3,[4,5]]
l3


# 2. 색인
l1[0]           # 정수색인 가능(positional indexing)
l1[0:3]         # 슬라이스 색인 가능(slice indexing)
l1[[0,2]]       # 여러 개 동시 색인 불가(list indexing 불가)
l1[-1]          # 거꾸로 색인(reverse indexing)
l3[3]           # [4,5]

l1[1]           # scalar return(차원 축소 발생)
l1[1:2]         # list return(슬라이스 색인을 통한 차원 축소 방지, in R : drop=F)


# 참고- Series의 기능
from pandas import Series

l1 + 1               # 연산 불가
Series(l1) + 1       # 연산 가능

l1[[0,2]]            # 색인 불가
Series(l1)[[0,2]]    # 색인 가능


# 3. 연산
l1 + 1               # 산술연산 불가
l1 > 1               # 비교 불가
l1 == 3              # 원소별 비교가 아님

l2 = [10,20,30,40]

l1 + l2              # 리스트 확장(결합)
l1 * 3               # 리스트 반복

# 4. 구조 변경
l1 = l1 + [5]        # 원소 추가
l1.append(6)         # 원소 추가(객체 직접 수정)
l1.extend([7])       # 원소 추가, 리스트 확장(반드시 리스트로 전달 필요, 객체 직접 수정)
l1.insert(1, 10)     # 원소 추가(원하는 위치 지정 가능, 객체 직접 수정)

l1.remove(10)        # 10인 원소 삭제(객체 직접 수정 됨)
del(l1[1])           # 두번째 원소 삭제(위치기반 삭제)
del(l1)              # 객체 삭제 가능

l1 = [1,2,3,4,5]
l1.pop()             # 맨 마지막 원소 꺼내기(객체 직접 수정 됨)
l1.pop(1)            # 특정 위치 원소 꺼내기(객체 직접 수정 됨)

l2 = [1,3,10,2,5]
l2.sort() ; l2                   # 정렬(객체 직접 수정 됨)
l2.sort(reverse=True) ; l2       # 정렬(객체 직접 수정 됨)

l2.count(5)                      # 5가 포함된 횟수


# 5. 수정
l1[0] = 100
l1[1:3] = [400,500]


# [ 연습 문제 ]
# 1. 1~5까지의 숫자 원소를 갖는 l1 생성
l1 = [1,2,3,4,5]

# 2. 10,20,30,40,50의 숫자 원소를 갖는 l2 생성
l2 = [10,20,30,40,50]

# 3. l1에서 두번째 원소 삭제
del(l1[1])

# 4. l2에 40 원소 삭제
l2.remove(40)

# 5. l1의 세번째에 100 삽입
l1.insert(2,100)

# 6. 두 원소를 하나의 리스트로 합쳐 출력
l1 + l2
l1.extend(l2)

# [ 함수와 메서드 ]
# 1. 함수 : input value(자료구조)가 함수 안에 전달
# 2. 메서드 : input value(자료구조)가 먼저 호출 ->> 이어서 함수가 출력

import math
dir(math)    # 함수 목록
dir(l1)      # 선언된 변수의 타입에 따른 메서드 목록

s1 = 'a'
dir(s1)      # 문자열 메서드 목록


# =============================================================================
# 문자열 메서드
# =============================================================================
# 1. 추출
a1 = 'abcde ab'
a1[1:3]
a1[:3]    # 처음부터
a1[1:]    # 끝까지
a1[:]     # 처음부터 끝까지

# 2. 대소치환
dir(a1)

a1.upper()
a1.lower()
a1.title()

# 3. 시작 / 끝 여부
a1.startswith('a')
a1.startswith('a', 1)    # 두번째부터 추출한 문자열이 a로 시작하는지 => 두번째값이 a인지 여부

a1.endswith('a')

# 4. 공백 제거
a2 = ' abc '
a2.strip()       # 양쪽 공백 제거
a2.lstrip()      # 왼쪽 공백 제거
a2.rstrip()      # 오른쪽 공백 제거

a1.lstrip('a')   # 연속적인 문자열 제거 가능

# 5. 치환
a1.replace('a','A')   # 치환(정규식 표현식 사용 불가)
a1.replace('a','')    # 삭제 가능

# 6. 분리
a3 = 'a#b#c#d'
a3.split('#')[1]

# 7. 위치
a3.find('#')      # 처음 발견된 문자열 위치 리턴(n번째 발견된 이라는 옵션 없음)
a3.find('#', 2)   # 세번째 문자열부터 스캔하여 처음 발견되는 #위치

# [ 연습 문제 ]
ename = 'smith'
tel = '02)333-4456'
jumin = '901111-1111111'
vid = 'abc1234!'

# 1) ename의 두 번째 글자가 m으로 시작하는지 여부 확인(True, False 확인)
ename.startswith('m',1)
ename[1] == 'm'

# 2) tel 국번(333) 추출
# 2-1) 위치기반
vno1 = tel.find(')')    
vno2 = tel.find('-')    

tel[(vno1+1):vno2]

# 2-2) 분리기반
(tel.split(')')[1]).split('-')[0]


# 3) 여자인지 여부 확인(True, False 확인)
jumin[7] == 1      # 숫자와 문자 비교 시 주의!
jumin[7] == '2'




